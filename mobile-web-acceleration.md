# 移动Web加速技术概述

> For TPAC 2017
> version 1.0

## Abstract

## Introduction
参与Web技术建设的几个重要角色分别是内容分发平台、浏览器提供商和网络提供商以及Web站点。每个角色都在自己所擅长的领域通过技术创新来给用户提供更快速的移动Web体验。移动Web加速的几个技术方向也和几个重要参与者的角色职能密不可分。

移动Web加速技术可以分位几个主要方向，分别是页面加载、页面构建与网络层优化。本文也将从几个方向分别介绍其解决的问题以及设想的解决方案，并针对解决方案补充有意义的用例。

近几年已经有许多公司推出了很多针对自己所在业务场景下的移动Web速度优化解决方案，但其中有存在一些问题：一是此类加速方案看似能解决移动Web访问速度的一部分问题，但实际只被某个浏览器厂商或某个内容分发平台使用，并没有推广到更大的应用范围；另一个是移动Web速度上的问题缺乏统一的汇总与大范围的讨论，移动Web速度问题相对复杂，更需要浏览器、内容分发平台、网络提供商紧密合作才能达到更好的效果。

我们希望将目前的问题以及解决思路和用例更全面的总结与汇总，在更大范围内一起讨论更为通用的Web加速技术解决方案，让Web开发者更便捷、更合理的使用此类技术。

## 页面加载
当网站已经按照一些标准（类似amp mip，或者简单的静态化基础html页面）进行构建之后，重要的是让用户的浏览器或者app在用户访问页面之前就完成页面的获取，甚至初步的渲染和一些有限的资源加载工作，提供可控的动画和页面加载容器，并在用户点击的时候结合动画过程并行进行渲染和资源加载。当这些工作都做完后，用户在大多数网络（甚至在高延迟的移动网络下）和设备上都可以达到接近本地NA的体验。

### 页面预取/预渲染

#### 解决的问题
移动浏览器中通常点击链接的渲染过程如下：
域名解析-》建立连接-》发起请求-》处理请求-》网络传输-》渲染页面-》加载资源

对于移动互联网用户来说，这些环节太多，会耗费很多的时间，类似amp和mip这类标准已经提供了cdn的缓存和渲染过程的优化，但是对于加载策略，预渲染控制，容器都还没有标准或者基于trick的实现，并没有办法完全追平NA端的体验。下面简单描述下存在的问题。

* 加载策略
	-   没有标准，哪些页面可以预先加载，要遵循什么标准。
	-   缺乏保证安全性的跨域预加载。
    
* 预渲染控制
	-   缺乏预渲染机制，以及对渲染过程的控制。
	-   缺乏对资源加载和代码执行的控制。

* 容器
	-   类似iframe这样的容器相对于和NA结合的webview，渲染和动画性能太差，例如要实现新页面左滑出现的效果，如果不同步渲染就会有白屏和转圈的等待，如果在滑动过程中渲染就会卡顿。
	-   缺乏对容器进行加载和预渲染的控制。

#### 解决方案

*  预加载
	-   预加载的标准
	-   预加载的异步化
	-   预加载的跨域加载
	-   预加载资源的浏览器缓存预充

* 预渲染
	-   预渲染的级别
	-   预渲染的参数
	-   预渲染的cpu优先级
	-   预渲染过程中的预加载

* 容器
	-   浏览器提供类似webview的机制，代替iframe，可循环利用，控制层次。
	-   容器支持预加载和预渲染中提到的特性
	-   容器支持动画过程中渲染
	-   容器支持在后台初始化

#### 用例

在基于web的feed 流 或者 搜索结果中应用，在webapp中应用，达到NA的效果。

### 加速服务缓存
  在站点日常运营过程中，速度是用户体验的重要指标之一。各类的云加速缓存服务也应运而生。这类服务一般有众多的节点，分布式缓存也都分别被部署到这类节点上，以期待用更快的速度给用户返回相应的结果。然而，不同的加速服务提供商对缓存的处理策略不尽相同，本小节总结了这类问题，并尝试从网站开发者角度提出对开发者更友好的缓存服务标准。
#### 面临的问题
* 浏览器部分云加速服务，对页面的修改以及缓存对开发者过于透明不可控，包括但是不限于：
	* 站点无法控制那些页面可以被缓存，那些页面不能被缓存。
	* 页面缓存失效相关的时间，大部分的CDN都支持Cache-Control头来控制相关更新，但是还没有形成业界统一的规范
#### 解决方案
* 站点的robots.txt文件里边新增字段来控制那些页面可以被缓存，那些页面不能被缓存，例如
* 缓存时间统一用`Cache-Control`头来控制缓存超时,用`stale-while-revalidate`头来控制平滑更新。

#### 用例
比如，一个网站的开发者，自己站点的`/home/news/data` 路径下的所有页面都是高时效性的页面，不希望被任何加速服务缓存。为了达到这个目的，站长应该在自己站点的`robots.txt`文件中加入如下内容：
```
Cache:*
HttpsCacheDisallow:/home/news/data/
HttpCacheDisallow:/home/news/data/
#对于所有的Cache来说，https和http的在/home/news/data/路径下的所有内容不允许倍缓存
```
所有遵循了缓存规范的服务解析站点的robots.txt文件后，不缓存/home/news/data路径下的所有内容。满足了开发者的需求。
当然，作为站长，也不能滥用此规范，因为不缓存的页面往往意味着更慢的加载速度。
### 加速服务数据回传
加速服务在缓存加速页面的同时，也会给站长带来数据统计上的困扰。本小节试图从数据统计的方面，提供缓存服务的一些规范。
#### 面临的问题
* 部分页面强依赖请求的CIP来做一些策略
* 部分站长需要实时知道自己站点的pv特征
* 缓存后，这些信息尚无明确规范回传给站长
#### 解决方案
* 所有的云端缓存在回传回原等数据的时候都加上`x-forward-for`头来指名真实的用户IP信息
* 页面中新增一个专门用于日志回传的组件。并设置相关日志域名robots.txt为不允许任何缓存。
#### 用例
对于需要实时知道自己站点访问pv的站长来说，可以使用上文所述的缓存规范配合自己额外的日志统计组件来解决这个问题；首先，我需要有一个域名，这个域名仅仅作为数据统计使用，不要允许任何的缓存系统对这个域名相关的请求做缓存。而后，页面里边单独开发一个日志统计组件。组件的功能就是，发送这次pv相关的信息到数据统计域名上。这样每当用户访问时，就可以拿到由组件打印的，真实用户访问pv了。大概步骤可以参看如下代码段。
```
1. 页面里边新增js打印日志组件
2. 统计日志域名的robots.txt增加以下内容
Cache:*
HttpsCacheDisallow:/
HttpCacheDisallow:/
```

### 云端缓存对预取的支持
在移动互联网下，仅仅是分布式的缓存服务还解决不了从缓存服务器到用户设备之间的移动网络传输慢的问题。因此，浏览器或者NA端做适当的预取策略，也是提高打开速度，优化体验的重要手段之一。同样的，预取在解决了用户体验的同时，也给开发者带来了许多困惑。本小节将通过对规范的探讨来解决预取带来的问题。
#### 面临的问题
* 高命中率的预取策略，适当的预渲染策略是移动浏览器提高页面打开速度的利器之一
* 开发者页面经过云端加速（包括但是不限于CDN，分布式云加速Cache等）需要有有效的标识被浏览器识别是预取流量
* 对于不缓存的页面，不应该被预取，以免给站点带来太大压力

#### 解决方案 

* 浏览器自带的云加速服务，在预取之前先爬取站点的robots.txt做缓存
* 对于允许缓存的页面，直接预取即可，但是header里边带上预取标识`X-moz: prefetch`，让站点知晓预取请求
* 对于不允许缓存的页面，预取到达缓存后，直接返回失败，不再预取
#### 用例
对于加速服务来说，要能正确的支持`X-moz:prefetch`的透传。对于站点来说，根据`X-moz`头来识别是否是预取请求，已完成更加精准的数据统计工作。对于浏览器来说，和自己的云加速服务配合好，仅仅预取允许缓存的页面，防止给站点带来过大的压力。
### 免流代理在云端加速服务上的标准
移动互联网发展的同时，相对高昂的流量费用有时候也成为了掣肘用户更多的上网的重要因素。因此，某些比较倍用户喜爱的app和运营商联合退出了各种免流套餐如腾讯的大王卡，百度大圣卡等等。对于免流这种场景来说，和运营商之间的约定的IP白名单是重要的手段之一。在免流场景中，往往需要站长手动将自己的服务调度到某些免流的IP上。因此，站长往往不希望自己的免流相关服务被不免流的IP代理。本小节从规范上说明这类情况站长应该怎么处理。

#### 面临的问题
* 部分站长有和运营商合作的免流套餐等需求（如大王卡，大圣卡）
* 这部分策略大部分和站点本身的IP强绑定
* 加速服务上线后，IP会归属于加速服务提供方而不是站点
#### 解决方案
* 免流代理必须用dns或者域名解析托管的方式来接入，不能是透明代理
* 所有的免流相关域名，robots.txt设置为不能被所有透明的云端加速缓存，防止劫持。
#### 用例
对于站长来说，首先将自己的域名所托管的所有的IP（包括所用的云加速的）和运营商约定好，都免流。
对于需要免流的域名，robots.txt都要设置为进制各种代理缓存。
对于自己的app，有可能访问的第三方数据，可以利用自己的已经免流的代理做透明代理。


### 关于Cache对请求的修改标准
在解决了缓存问题，数据透传问题，免流问题的同时，代理加速服务还可以做更多的事情让页面打开更友好。但是几乎没什么规范的页面修改也给业务带来了潜在的风险。
#### 面临的问题
* 为了进一步提高页面打开速度，部分代理都会对页面做相应修改
* 但是对于特殊业务来说，看上去合理的修改有可能导致严重的服务问题
#### 解决方案
* 云端Cache可以修改的内容为
	* 图片的格式
	* 图片的分辨率
	* 传输过程中无损压缩算法（保证浏览器能正确反解的前提下）
* 对于明确的特殊类别的页面（MIP，AMP）页面发布之初就是可以被缓存的，可以参照AMPCache和MIPCache的处理方案来做相应修改。
#### 用例
对于缓存服务来说，常见的修改功能如下：
* 缓存服务针对页面里边含有accept:image/webp的可以将图片转换为webp返回
* 缓存服务针对UA信息，压缩特定分辨率的图片返回
* 缓存服务部署amp，mip的识别能力，根据校验结果，按照对应的cache标准修改页面内的内容


### 搜索引擎爬虫识别与抓取策略控制
各级缓存在加速用户访问的同时，也给搜索引擎的抓取增加了一些难度。在速度/抓取成功率和时效性上，站长面临一些选择。此外，缓存造成了比较多的可能的内容出口，也可能给搜索引擎带来一些困惑：究竟页面的内容来源是那里。
#### 面临的问题
* 抓取流量是一把双刃剑，过于严苛的控制不利于搜索引擎及时发现内容，过于宽松的控制容易造成额外的压力和内容外泄
* 站长使用加速服务之后，页面更新时效性收到部分影响，对搜索引擎发现的时效性也会有影响
#### 解决方案
* 对于浏览器自带的云加速这类透明的缓存系统，禁止一切抓取（robots.txt）
* 对于站长主动配置的云端缓存（免流代理，CDN加速）针对搜索引擎的抓取请求，可以应站长需求，直接回原站或者直接返回缓存
* 对于站长主动配置的云端缓存，缓存系统要对知名搜索引擎的抓取出口和稳定性做优化，更好的抓取稳定性代表更好的时效性。
#### 用例
1. 透明缓存的代理在robots.txt中标明：禁止一切搜索引擎抓取器抓取。
2. 站长主动配置的云端缓存来说，可以根据站点的特征，和站长确认配置，究竟是直接回原抓取还是直接从缓存抓取。

## 页面内容性能分级标准

> 参考链接：[ContentPerformancePolicy](https://wicg.github.io/ContentPerformancePolicy/)

随着移动Web的大量普及，页面内容性能已经成为当前Web技术中的讨论热点，因为各大互联网公司都意识到，优化移动Web的性能就是在优化用户体验，移动Web性能与用户体验有着密不可分的关系！

本章节主要描述关于移动Web页面的性能实践方法建议以及基于最佳实践方法给出的页面性能评级策略。基于标准的评级策略，任何页面使用方（内容平台、浏览器、用户）都可以使用策略来提升用户访问Web的体验。

### 解决的问题

* 构建良好页面性能标准
* 页面性能评价标准

### 解决方案

## 网络层优化
通常在网站节点异常时会调整域名的DNS解析映射，将用户流量调度到可用节点IP。传统的DNS协议存在解析收敛慢、中间节点缓存与劫持问题，推进HTTP DNS 目的旨在加速dns解析、提升DNS安全性。本文的考虑将HTTP-DNS作为数据服务嵌入HTTP header，不考虑建设internet集中式的HTTP-DNS解析系统，主要考虑点是依赖ISP做较多的基础设施建设。

### 概述

传统的DNS解析通过UDP协议查询，Local DNS递归查询解析记录，权威NS server根据localdns ip判断需要返回的解析ip。对于网站的可用性重点关注以下几方面， * 解析效率：递归节点缺少统一控制，全网收敛时间通常大于TTL。HTTP alternete services（RFC 7838）提供了一种服务调度的思路，在加速解析方面不够灵活。

* 解析精度： 传统的递归解析使用local dns ip来判断就近返回的站点ip，不能精确反应真实用户地理未知。（权威DNS支持edns扩展RFC 7871，大部分ISP的递归节点不支持）。

* DNS安全：DNS query不是安全的协议，无法避免中间环节的劫持。


### 解析效率和调度精度

#### 面临的问题

* 递归解析由于递归层级和cache因素无法满足分钟级GTC调度(外网流量调度)；

* 站点IP连接故障的情况期望能立即重试备用IP；

* 递归节点和用户地理拓扑不一定临近，精准的流量调度需要用户ip。

#### 解决方案

* HTTPS header传递解析信息: 浏览器HTTPS req header携带协议头询问服务端是否支持HTTP-DNS，如支持则webserver rsp header中携带解析信息，包括：{推荐IP，备用IP列表，TTL，缓存刷新标记，预解析接口}。

* 浏览器调度优先级: 浏览器解析header信息，下次请求根据header标记优先使用推荐ip调度请求，连接失败依次重试备用ip列表，备用ip不可用则回退到递归解析。浏览器发起的req header中携带重试信息，用于服务端GTC决策。 * 缓存方式：浏览器维护HTTP-DNS 缓存，{域名，推荐ip，备用ip，TTL}，rsp header的缓存刷新标记位非0时无论TTL是否过期立即刷新缓存。

* 预解析：TTL过期的HTTP-DNS信息在浏览器启动时用于预解析，按”浏览器调度优先级”描述的优先级建立解析缓存。预解析是一次HTTPS请求，（建议）rsp header中提供专用的解析接口，避免增加业务负载。

* 服务端调度: webserver对支持HTTP-DNS的浏览器请求，在header中返回解析信息。服务端GTC调度，则修改”推荐ip”和”缓存标志位”让浏览器立即刷新缓存。GTC根据用户clientip和对dns的重试信息，更加精准的调度。

* 用例

* 精准调度：浏览器透传用户ip和dns重试信息

* 解析速度：(参见header定义)缓存刷新标记位可以立即刷新解析信息，浏览器的预解析加速加速第一次解析，后续的解析复用缓存。

### DNS安全性

#### 面临的问题

* web站点无法预期DNS劫持和缓存污染故障的发生，也无法施加有效控制，依赖ISP刷新缓存活用户切换Local DNS，止损流程复杂，通常服务持续有损。

#### 解决方案

* 基于TLS协议的解析信息交换：HTTP DNS中的解析信息交换必须使用TLS，在有预解析的情况下曾经成功发起过HTTPS请求的用户后续的DNS解析都是安全的。对于第一次发起HTTPS请求的用户仍然依赖递归解析，存在不安全。下文单独阐述

* 浏览器HTTP-DNS缓存隐私：HTTP-DNS设置高隐私等级，建议只读，减少本地篡改。

### 特殊场景

* 第一次HTTPS请求的DNS安全：

* 浏览器预加载列表（建议）：对没有本地缓存记录的域名默认使用递归查询，异步对预加载列定义的探测接口探测HTTP-DNS信息，如域名支持HTTP-DNS则后续的请求使用更新后的缓存。预加载列表建议由权威中间机构维护（类似CA），web站点向中间机构注册，并约束SLA。

* 3G和wifi制式切换HTTP-DNS缓存刷新

* 制式切换用户网络接入拓扑发生变化，浏览器感知制式切换重建连接时强制立即刷新缓存。

## 移动端Webview加速
无论是安卓还是iOS系统，在移动端的Native App上打开web页面、web应用均是通过创建webview的方式来进行的，webview的性能直接影响到web页面打开的性能，webview的易开发和易维护也直接影响到移动端开发和变更的效率。大量的实际应用中，可以发现移动端上的webview的性能存在诸多不足，一定程度上已经成为了Native App上影响用户web体验的关键因素之一，而且目前并没有全面、通用的解决方案。

#### 解决的问题
Native App上使用webview打开web页面和web应用，主要存在如下的一些性能、开发维护上的不足或问题：

 - 移动端创建一个webview的过程很慢，耗时长，造成web打开体验的不流畅，等待动画时间过长；
 - 移动端上的webview的使用上，默认每一个web页面的打开都需要新创建一个webview，没有webview的复用机制，特别对于web页面多的应用，需要频繁的创建和删除，资源开销大，性能差；
 - 创建后的webview，如果不删除该webview，那么它里面展现的内容不能或者不易进行清除和替换，同时强行替换还容易出现显示异常；
 -  目前移动端的webview无法在后台进行创建，创建过程中如果不注意处理，webview就会占用Native App上的UI线程，会造成页面的卡顿，对开发者带去难题；
 - 已经加载页面的webview无法实现后台待命并在需要读取同一页面的时候直接调出而不再重新读取页面数据，目前每次web页面读取时，无论用户是否已读，无论页面是否有缓存，都是需要重新加载页面；
 - 受移动操作系统的限制，webview在打开web页面的动画过程中，无法进行同步渲染，而只能显示动画，没法通过打开过程中提前渲染来使动画时间减少、提高视觉体验；
 - 移动端上的webview不能实现用户更快看到内容展现在屏幕上，需要等页面及其内容完整渲染完之后，才能开始显示到屏幕上，制约了性能改善和开发者；
 - 在硬件绘制方面，每增加一个新的webview在屏幕上显示，都需要在移动终端上进行硬件资源的申请和释放，独占的特性使得不能做到对硬件资源充分和有效的复用，频繁的申请和释放极大的影响了性能和浪费了资源；
 - 多个webview显示在同一个屏幕，对移动终端资源占用大，使用卡滞不流畅，用户体验差，制约了开发者的开发；
 - 移动端上的webview自身缺乏多实例的管理，对端的依赖较多，制约了开发者的开发；
 - 移动端webview缺乏整套对外开放的通用的下载、读取及缓存的通用能力及相应的管理和维护能力，Native App上为了实现下载、读取、缓存管理，进行了各种不同的开发实现，多是临时、短线方案，给端上持续开发、更新带去不少挑战，而这随着页面元素内容及其操作的增多将更加严重；
 - 随着系统版本不同，webview自身版本也会不同（比如回调的修改和增删），在兼容性方面对开发者具有很大的挑战。
 - 移动端上的webview无法获取或提供页面当前屏幕部分完全渲染展示在屏幕上的时间点，对于开发评测带去挑战。
		
#### 解决方案
面对上述罗列的移动端webview使用过程中的各种性能、开发和维护方面的不足或问题，下面重点针对其中主要的一些问题，给出解决方案：

 - 移动端在web页面打开之前实现webview的预先创建，解决webview创建慢的问题，同时webview创建可以实现在后台进行，不影响移动端上的UI效果。
 - 移动端实现webview的复用，解决频繁创建和删除的问题，可以按照实现分为三个层次：
	Level 1：打开web页面前预先在移动端创建一个webview，在页面退出时删除这个webview，并创建一下各新的一个新的webview待用。
	Level 2：移动端上的webview只需要创建一次，退出页面后，新的页面打开时可以直接复用该webview，在退出页面时清除webview中的原页面内容，但不删除webview，然后填充新页面，或者直接支持在webview里新页面替换已有页面。
	Level 3：之处多个webview同时存在、协同使用，webview实现多实例的管理，具体来说单个webview可以支持复用，多个webview均可加载页面，同时多个webview之间可以无缝的切换。
 - 移动端webview添加到屏幕显示不独占硬件资源，支持并行化的渲染，充分复用硬件资源，并且支持对移动端硬件资源的更好管理，避免频繁和重复申请和释放。
 - 移动端webview支持对渲染方式的配置，可以支持内容的优先渲染和展示到屏幕上
 - 移动端webview提供对端开放的通用的下载、读取、缓存管理能力。

#### 用例
当今的移动互联网进入内容分发时代后，新闻资讯类、社交分享类应用大量出现，在native App上，其中图文、图集、广告、第三方页面等web页和应用均使用webview打开。通过webview预先创建和复用将webview的耗时和资源频繁占用和使用降到尽可能低的程度，可以较大的提高web页面和应用打开的速度和体验，同时也能提高整个Native App的开发便利性和运行效率。
## 参考
